---
sidebar_position: 5
---

# Advanced usage

## Audio/Video config options while joining meeting.

```kotlin {3,4}
let meetingInfo = DyteMeetingInfoV2(
  authToken: AUTH_TOKEN,
  enableAudio: true,
  enableVideo: true,
)

meeting.doInit(dyteMeetingInfo: meetingInfo)
```

## Local user usages

To show localUser preview inside a view. Use `getVideoView()` method on
localUser. This method returns a View which can be added in any View.

```swift
meeting.localUser.getVideoView()
```

### Turn audio/video tracks after joining the room

If audio and video tracks are disabled during the `DyteMobileClient`
initialization process. You can setup the audio and video tracks by simply
calling `enableAudio()` and `enableVideo()` like below:

```swift
meeting.localUser.enableAudio()
meeting.localUser.enableVideo()
```

### Change the name of the local user

Change the user's name by calling `setDisplayName` method. The changed name will
reflect across all participants ONLY if the change happens before `joinRoom()`
the meeting and after `init()`.

```swift
meeting.localUser.setDisplayName("New Name")
```

### Mute/Unmute microphone

```kotlin
// Mute Audio
meeting.localUser.disableAudio()

// Unmute Audio
meeting.localUser.enableAudio()

// Get current status
meeting.localUser.audioEnabled
```

### Enable/Disable camera

```kotlin
// Disable Video
meeting.localUser.disableVideo()

// Enable Video
meeting.localUser.enableVideo()

// Get current status
meeting.localUser.videoEnabled
```

### Switch camera between primary and secondary

```swift
// switch camera
meeting.localUser.switchCamera()
```

OR

If you want to set video device yourself:

```swift
meeting.localUser.setVideoDevice(videoDevice: DyteVideoDevice)
```

## Room participants object.

- `joined`: A list that contains all the participants who have joined the
  meeting.
- `waitlisted`: A list that contains all the participants waiting to join the
  meeting.
- `active`: A list that contains all the participants except the local user who
  are supposed to be on the screen at the moment
- `pinned`: A nullable participant object. If any participant is pinned is that
  participant else it is null.
- `screenshares`: A list that contains all the participants who have shared
  screen in the meeting.
- `gridInfo`: This object has all data related to pages in the room.

Each participant in each of the `joined`, `waitlisted`, `active` and
`screenshares` list is of type `DyteMeetingParticipant`.

For example, to get all the participants who joined the meeting:

```swift
// get all joined participants
let joinedParticipants = meeting.participants.joined;
```

For example, to get all the active participants in the meeting:

```swift
// get all active participants
let joinedParticipants = meeting.participants.active;
```

Therefore, if you were to make a grid of participants, you'd use the `active`
list, but to display all participants in the meeting you'd use the `joined`
list.

### Grid info for the room

Following object can be retrieved from `meeting` object by using
`meeting.participants.gridInfo`. This object will have necessary information
regarding pageCount, next page, previos page, current page, etc.

```swift
  let pageCount: Int
  let currentPageNumber: Int
  let isNextPagePossible: Bool
  let isPreviousPagePossible: Bool
  let shouldShowPaginator: Bool
  let maxVideoCountPerPage: Int
```

### Video update for all participants

Triggered when the user starts / stops the video using `enableVideo` or
`disableVideo`

```swift
extension MeetingViewModel: DyteParticipantEventsListener {
     func videoUpdate(videoEnabled: Boolean, participant: DyteMeetingParticipant) {
      if (videoEnabled) {
        // video is enabled, and other participants in room can see local user
      } else {
        // video is disabled, and other participants in room can not see local user.
      }
    }
}
```

### Audio update for all participants

Triggered when the user starts / stops the audio using `enableAudio` or
`disableAudio`

```swift
extension MeetingViewModel: DyteParticipantEventsListener {
    func audioUpdate(audioEnabled: Boolean, participant: DyteMeetingParticipant) {
      if (audioEnabled) {
        // audio is enabled, and other participants in room can hear local user
      } else {
        // audio is disabled, and other participants in room can not hear local user.
      }
    }
}
```

### Move between pages in paginated mode

The `setPage(pageNumber: Int)` method allows you to switch between pages of
participants present in the meeting.

```swift
// switch to 1st page
meeting.participants.setPage(1)
```

### Host control methods

The `meeting.participants` object has host control methods that allow you to
disable the audio and video streams of other users in the meeting (given that
the user preset has the right permissions).

```swift
// mute all participants
meeting.participants.disableAllAudio()

// mute a single participant
let participantToUpdate = meeting.participants.joined.first
participantToUpdate.disableAudio()

// disable video for all participants
meeting.participants.disableAllVideo()

// disable video for a single participant
let participantToUpdate = meeting.participants.joined.first()
participantToUpdate.disableVideo()
```

To remove all participants from a meeting, you can call the `kickAll()` method.

```swift
// remove all participants from the meeting
meeting.participants.kickAll()

// remove a single participant
let participantToRemove = meeting.participants.joined.first()
participantToRemove.kick()
```

## Interacting with chat

The meeting chat object is stored in `meeting.chat`, which has methods for
sending and receiving messages. There are 3 types of messages that can be sent
in chat - text messages, images, and files.

The `meeting.chat.messages` array contains all the messages that have been sent
in the chat. This is an array of objects, where each object is of type
`DyteChatMessage`.

We support three types of chat messages, they are as follows

- Text Message
- Image Message
- File Message

All above objects are of type `DyteChatMessage` along with their own class
variables.

There are 3 types of chat messages - text messages, images, and files. 
There is a method in `meeting.chat` to send a message of each type.

### Send a text message

To send a text message, the `meeting.chat.sendTextMessage()` method can be used.
This accepts a string `message` and sends it to the room.

```swift
let message = "Is this the real life?"
meeting.chat.sendTextMessage(message: message)
```

### Send an image

You can send an image with the help of `meeting.chat.sendImageMessage()` and
sends it to the participants in the meeting.

```swift
let filePath = "file_path_of_image"
let fileName = "file_name"
meeting.chat.sendImageMessage(filePath: filePath, fileName: fileName)
```

### Send a file

Sending a file is quite similar to sending an image. The only difference is that
when you send an image, a preview will be shown in the meeting chat, which is
not the case for sending files. That being said, an image can be sent as a file
too using `meeting.chat.sendFileMessage()`.

```swift
let filePath = "file_path_of_image"
let fileName = "file_name"
meeting.chat.sendFileMessage(filePath: filePath, fileName: fileName)
```

### Receiving chat messages

To be able to receive chat messages you need to implement a method
`onChatUpdates()` method from callback `DyteMeetingRoomEventsListener`. You can
subscribe to this events by calling
`meeting.addMeetingEventsListener(dyteMeetingRoomEventsListener)`

```swift
    extension MeetingViewModel: DyteMeetingRoomEventsListener {
      func onChatUpdates(messages: [DyteChatMessage]) {
        // any update in chat messages
      }

      func onNewChatMessage(message: DyteChatMessage) {
        // updates for new chat messages only
      }
    }
```

Here, the `message` is of type `Message`, as defined in
[introduction](./introduction). `messages` is a list of all chat messages in the
meeting, which is the same as `meeting.chat.messages`.

When a chat message is received, the `meeting.chat.messages` list is also
updated.

## Get info about the plugins configured for the meeting

The meetings plugins can be accessed using `meeting.plugins`. It provides two
main objects, `all` which contains list of all Plugin objects in a
`DyteMeeting`. And `active` list which contains plugins which are enabled and
are currently being used in this meeting.

### Playing with plugins

Plugins are webviews which can be added in any view. To be able to get webview
from DytePlugin one needs to first acivate a plugin. To do that all we need to
do is call `plugin.active()` which will trigger a callback in
`onPluginActivated()`. Similarely to deactivate a plugin one can call
`plugin.deactivate()` and that plugin will be deactivated in the meeting.

```swift
plugin.activate() // to activate a plugin
plugin.deactivate()   // to deactivate a plugin
```

### Active plugin

To check if a `plugin` is active or not in a meeting one can use

```swift
let isActive = plugin.isActive
```

### Listening to plugins in a meeting

To be able to listen to plugin events you need to implement a methods from
callback `DytePluginEventsListener`. You can subscribe to this events by calling
`meeting.addPluginEventsListener(dytePluginEventsListener: listener)`

```swift
    extension MeetingViewModel: DytePluginEventsListener {
      func onPluginActivated(plugin: DytePlugin) {
      // your code to handle plugin activation
    }

    func onPluginDeactivated(plugin: DytePlugin) {
      // your code to handle plugin de-activation
    }
}
```

## Recording

The `meeting.recording` object can be used start and stop recordings in a
meeting. You can also get the current status of a recording using this API.

The `meeting.recording` object has the following properties:

- `recordingState`: Indicates the current recording state of the meeting.

### Start a recording

To start a recording, you can call the `start` method in the `meeting.recording`
object. The valid states are `IDLE`, `STARTING`, `RECORDING`, and `STOPPING`.

```swift
meeting.recording.start()
```

### Stop a recording

Call `meeting.recording.stop()` to stop the active recording.

```swift
meeting.recording.stop()
```

### Get active recording state

The `meeting.recording.recordingState` property describes the current state of
the recording. The valid states are `IDLE`, `STARTING`, `RECORDING`, and
`STOPPING`.